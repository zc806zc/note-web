# IDEA配置

- sass\less

- autoprefix

  - <http://www.css88.com/archives/5670>
  - <https://www.npmjs.com/package/less-plugin-autoprefix>

```javascript
npm install autoprefixer -g
npm install postcss-cli -g
npm install -g less
npm install -g less-plugin-clean-css
C:\Users\Administrator\AppData\Roaming\npm\postcss.cmd

--plugin=less-plugin-clean-css $FileName$

Parameters: -u autoprefixer -o $FileDir$\$FileName$  $FileDir$\$FileName$
Working directory :$ProjectFileDir$

// npm install postcss-less
```

# 模块导入导出

- <https://juejin.im/post/5a2e5f0851882575d42f5609>

  - import
  - require
  - export
  - module.exports

```javascript
require.ensure([], (require) => {
   callback(null, [
     require('./src/pages/profitList').default,
   ]);
 });

如果一个 es6 模块只有一个 default 输出，
那么在转换成 commonjs 的时候也一起赋值给 module.exports
即整个导出对象被赋值了 default 所对应的值
```

# 前端模拟数据

- mock.js | easy mock
- faker.js

  - <https://github.com/Marak/faker.js>

- json server

# 脚手架或构建工具

- fis3 <http://fis.baidu.com/fis3/docs/beginning/intro.html>

# Webpack

- 简介

  - 模块加载器 兼打包工具
  - Github 上各大主流的 React 相关项目，所展示的示例是基于 webpack 来开发的
  - <http://webpack.github.io/>
  - 入门 <http://www.w2bc.com/Article/50764>

- commonJS AMD/CMD 代码迁移

  - 替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等
  - 支持 React 热插拔??
  - demo 自动加上自己的加载器 回调define...
  - 每个项目下都必须配置有一个 webpack.config.js

- 按需加载

  - tree-shaking 通过静态分析 es6 的语法，可以删除没有被使用的模块

```javascript
var someModule = require("someModule");
    var anotherModule = require("anotherModule");    

    someModule.doTehAwesome();
    anotherModule.doMoarAwesome();

    exports.asplode = function (){
        someModule.doTehAwesome();
        anotherModule.doMoarAwesome();
 };

// 作用如同常规的 gulpfile.js/Gruntfile.js ，配置项，告诉 webpack 它需要做什么
var webpack = require('webpack');
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
// 提取多个入口文件的公共脚本部分
// 然后生成一个 common.js 来方便多页面之间进行复用

module.exports = {
    //插件项
    plugins: [commonsPlugin],
    //页面入口文件配置
    entry: {
        index : './src/js/page/index.js'
    },
    //入口文件输出配置
    output: {
        path: 'dist/js/page',
        filename: '[name].js'
    },
    // module.loaders 是最关键的一块配置
    // 它告知 webpack 每一种文件都需要使用什么加载器来处理
    module: {
        //加载器配置
        loaders: [
            { test: /\.css$/, loader: 'style-loader!css-loader' },
            { test: /\.js$/, loader: 'jsx-loader?harmony' },
            { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
            { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
        ]
    },
    //其它解决方案配置
    resolve: {
            //查找module的话从这里开始查找
            root: 'E:/github/flux-example/src', //绝对路径
            //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
            extensions: ['', '.js', '.json', '.scss'],
            //模块别名定义，方便后续直接引用别名，无须多写长长的地址
            alias: {
                AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
                ActionType : 'js/actions/ActionType.js',
                AppAction : 'js/actions/AppAction.js'
            }
        }
};


// 执行：$ webpack --display-error-details
// 其他
$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
$ webpack --watch   //监听变动并自动打包
$ webpack -p    //压缩混淆脚本，这个非常非常重要！
$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了

// 连样式都不用引入，脚本执行时会动态生成style并标签打到head里
// 脚本模块
require('../../css/reset.scss'); //加载初始化样式
require('../../css/allComponent.scss'); //加载组件样式
var React = require('react');
var AppWrap = require('../component/AppWrap'); //加载组件
var createRedux = require('redux').createRedux;
var Provider = require('redux/react').Provider;
var stores = require('AppStore');

var redux = createRedux(stores);

var App = React.createClass({
    render: function() {
        return (
            <Provider redux={redux}>
                {function() { return <AppWrap />; }}
            </Provider>
        );
    }
});

React.render(
    <App />, document.body
);

// 有用的技巧
// shimming：在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理
{ test: require.resolve("./src/js/tool/swipe.js"),  loader: "exports?swipe"}

require('./tool/swipe.js');
swipe();

// 自定义公共模块提取：
// 独立打包样式文件
var webpack = require('webpack');
    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        plugins: [commonsPlugin, new ExtractTextPlugin("[name].css")],
        entry: {
        //...省略其它配置


// 使用CDN/远程文件
{
    externals: {
        // require("jquery") 是引用自外部模块的
        // 对应全局变量 jQuery
        "jquery": "jQuery"
    }
}
var $script = require("scriptjs");
$script("//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js", function() {
  $('body').html('It works!')
});

// 与 grunt/gulp 配合
gulp.task("webpack", function(callback) {
    // run webpack
    webpack({
        // configuration
    }, function(err, stats) {
        if(err) throw new gutil.PluginError("webpack", err);
        gutil.log("[webpack]", stats.toString({
            // output options
        }));
        callback();
    });
});
```

# 压缩

- Gzip 传输时压缩

  - header Content-Encoding:gzip
  - appache mod_deflate模块
  - Node.js Express compress()
  - 预压缩 + HTTP报头Content-Encoding:gzip

- 缩编、混淆和编译

  - 缩编：去掉空格换行符
  - 混淆：高级 对限定作用域内的变量 重命名为简短的名称

    - 全局变量和函数越少越好

  - 编译：更先进 分析代码

- JS压缩

  - uglifyJS
  - YUI Compressor（仅仅压缩）
  - Closure Compiler

  - JSMin 缩编工具

    - npm install -g jsmin
    - jsmin -o Listing.min.js listing.js

  - UglifyJS 缩编 + 混淆

    - <http://marijnhaverbeke.nl/uglifyjs>
    - npm install uglify-js -g
    - uglifyjs uglify-test.js -m -o uglify-test.min.js

  - Google Closure Compiler 代码编译

    - <http://closure-compiler.appspot.com/home>

- CSS压缩

  - CSS Compressor

- css移除

  - uncss <https://github.com/giakki/uncss>

- HTML压缩

  - 有必要吗？
  - HtmlCompressor

- 图片资源压缩|优化

  - 在线

    - TinyPNG
    - JEPGmini
    - 智图 <http://zhitu.isux.us/>

  - 本地：ImageOptim

# Gulp

# JS文档

- 资源

  - [JSDoc](http://usejsdoc.org/) | [dox](https://github.com/tj/dox) | [YUIDoc](http://yui.github.io/yuidoc/)(业内倾向)

- node.js

- npm -g install yuidocjs

- cd /d , pushd dir

- yui (-n) .

- [github](http://yui.github.io/yuidoc/)

- [Dana主题](https://github.com/carlo/yuidoc-theme-dana)
- [more主题](http://yui.github.io/yuidoc/themes/)
- [官方语法指南](http://yui.github.io/yuidoc/syntax/)

```javascript
// 文档定义
从源代码中提取特殊格式的文档

类比jQuery的文档
可以提高代码的可维护性

但注意保证文档的及时更新

// 一般的开始格式

让文档处理器只能理解我告诉它的东西 // 不要太智能

// Markdown
更具表达性的文档格式
转化成HTML更容易!
富文本
语法高亮 coding

// 使用YUIDoc创建一个文档网站
```

# 静态代码分析工具

- [JSlint](http://www.jslint.com)

  - _jslint devel: true, nomen: true, white: true_
  - _global Class_
  - [在线文档](http://www.jslint.com/lint.html)

- [JSlint nodejs](https://github.com/reid/node-jslint)

  - npm install jslint
  - jslint *.js

- [JSHint](http://www.jshint.com)

  - 在意一个没有用到的变量
  - / _jshint devel: true, unused: false;_/
  - [在线文档](http://jshint.com/docs/options/)
  - npm install jshint -g
  - jshint *.js
  - [插件](http://jshint.com/install/)

- Google Closure Compiler

  - 提高JS代码的下载速度和执行速度
  - 发现语法错误
  - [在线](http://closure-compiler.appspot.com/home)
  - [java运行](https://developers.google.com/closure/compiler/docs/gettingstarted_app)
  - [REST Web服务API](https://developers.google.com/closure/compiler/docs/gettingstarted_api)

- Closure Linter

# 度量代码质量

- 代码覆盖率工具[Istanbul](https://github.com/gotwarlost/istanbul)

  - [ruanyf](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)
  - node.js npm grunt 任务执行器
  - npm install -g grunt-cli
  - npm install grunt-contrib-jasmine --save-dev
  - grunt default
  - [PhantomJS](http://phantomjs.org) 基于Webkit的无界面浏览器

- 代码分析 [Plato](https://github.com/es-analysis/plato)

  - npm install -g plato
  - plato -d reports src/*.js
