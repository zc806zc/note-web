# JS面向对象

- 传统的面向对象 C++ Java PHP Objective-C
- JavaScript是面向对象的，但基于prototype(原型), 而不是使用类

  - 需要模拟，需要处理封装、多态等问题
  - 更加灵活
  - 使用闭包

- 函数在 ECMAScript中是对象，不是一种数据类型。

- 但函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的

- 数据属性

  - [[Configurable]] 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性
  - [[Enumerable]] 表示能否通过 for-in 循环返回属性
  - [[Writable]]
  - [[Value]]

- 访问器属性

  - [[Configurable]]
  - [[Enumerable]]
  - [[Get]]
  - [[Set]]

- 两个内置对象/单体内置对象

```javascript
var person = {};
Object.defineProperty(person, "name", {
  writable: false,
  value: "Nicholas"
});
console.log(person.name); //"Nicholas"
person.name = "Greg";
console.log(person.name); //"Nicholas"

// 一旦把属性定义为不可配置的，就不能再把它变回可配置了
var person = {};
Object.defineProperty(person, "name", {
  configurable: false,
  value: "Nicholas"
});
//抛出错误
Object.defineProperty(person, "name", {
  configurable: true,
  value: "Nicholas"
});

// 定义访问器属性
var book = {
    _year: 2004,
    edition: 1
};
Object.defineProperty(book, "year", {
  get: function(){
      return this._year;
  },
  set: function(newValue){
      if (newValue > 2004) {
          this._year = newValue;
          this.edition += newValue - 2004;
      }
  }
});

book.year = 2005;
console.log(book.edition); //2

// 定义多个属性
var book = {};
Object.defineProperties(book, {
  _year: {
      value: 2004
  },
  edition: {
      value: 1
  },
  year: {
      get: function(){
          return this._year;
      },
      set: function(newValue){
          if (newValue > 2004) {
             this._year = newValue;
              this.edition += newValue - 2004;
          }
      }
  }
});

// 取得Global对象的一种方法
var global = function(){
return this;
}();
```

# 创建对象

```javascript
var person= {}; // 少用new
person.firstname="John";
person.run  = function(){}; // 自动添加属性

// 添加方法到对象
function person(firstname,lastname,age,eyecolor) {
  this.firstname=firstname;
  this.lastname=lastname;
  this.age=age;
  this.eyecolor=eyecolor;

  // 方法
  this.changeName=changeName;
  function changeName(name) {
     this.lastname=name;
  }

}
myFather = new person("John","Doe",50,"blue");
myFather.changeName("Doe");
```

# 实现继承

- 原型链
- 函数伪装
- 原型链 + 函数伪装(正确打开方式)

```javascript
// 第一部分
function Parent(name){
  this.color = ["red","blue"];
  this.name = name;
}
Parent.prototype.talk = function(){
  alert(this.name+"["+this.color+"]");
}

// 第二部分
function Child(name,age){
  //函数伪造继承
  Parent.call(this,name);
  this.age = age;
}

// 原型链继承
Child.prototype = new Parent();

Child.prototype.say = function(){
  alert(this.name+","+this.color);
}

//第三部分
var c1 = new Child("Leon",22);
c1.color.push("green");
c1.say();     // 输出：Leon[red,blue,green]
var c2 = new Child("Ada",25);
c2.say();     // 输出：Ada[red,blue]
```
