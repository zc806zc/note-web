# 内存泄露与性能瓶颈

- 内存管理 + 处理常见的4种内存泄漏 <https://juejin.im/post/5a2559ae6fb9a044fe4634ba>

  - C 这样的编程语言，有 malloc() 和 free() 这样的基础内存管理函数
  - 即使使用高级语言，开发者也应该对内存管理有一些理解
  - 内存生命周期
  - JavaScript自己执行了内存分配，同时声明了值

    - 在内存不再需要时释放内存
    - 高级语言嵌入了一个称为垃圾回收器的软件
    - 垃圾回收机制
    - 内存引用
    - 引用计数垃圾收集: 如果有零个指向它的引用
    - 标记和扫描算法

```javascript
function f() {
  var o1 = {};
  var o2 = {};
  o1.p = o2; // o1 references o2
  o2.p = o1; // o2 references o1\. This creates a cycle.
}

f();
```

# JS内存泄漏

- 全局变量: 赋值为 null 或重新赋值
- 被忘记的定时器或者回调函数
- 闭包

  - 一旦为同一个父作用域内的闭包创建作用域，作用域将被共享

- 超出 DOM 的引用

```javascript
function foo(arg) {
    bar = "some text";
}

// 超出DOM的引用
// 如果你在代码中保留对表格单元格（td 标记）的引用，
// 并决定从 DOM 中删除该表格但保留对该特定单元格的引用，
// 则可以预见到严重的内存泄漏

// 由于单元格是表格的子节点，
// 并且子节点保持对父节点的引用，
// 所以对表格单元格的这种单引用会把整个表格保存在内存中。

var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image')
};
function doStuff() {
    elements.image.src = 'http://example.com/image_name.png';
}
function removeImage() {
    // The image is a direct child of the body element.
    document.body.removeChild(document.getElementById('image'));
    // At this point, we still have a reference to #button in the
    //global elements object. In other words, the button element is
    //still in memory and cannot be collected by the GC.
}
```
