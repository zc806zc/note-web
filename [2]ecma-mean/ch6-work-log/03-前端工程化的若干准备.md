# ch17 错误处理与调试

- 使用 Web 的绝大多数人都不是技术高手，其中甚至有很多人根本就不明白浏览器到底是什么，更不用说让他们说喜欢哪一个了
- 使用 window.onerror 事件处理程序，这种方式可以接受 try-catch 不能处理的所有错误（仅限于 IE、Firefox 和 Chrome）。
- 错误类型

  - Error
  - EvalError
  - RangeError
  - ReferenceError
  - SyntaxError
  - TypeError 在变量中保存着意外的类型时，或者在访问不存在的方法
  - URIError

- 抛出错误的时机

- 只应该捕获那些你确切地知道该如何处理的错误

- 常见的错误类型

  - 类型转换错误
  - 数据类型错误
  - 通信错误

    - 将数据发送给服务器之前，没有使用 encodeURIComponent() 对数据进行编码

- 区别致命错误和非致命错误

  - 非致命错误

    - 不影响用户的主要任务；
    - 只影响页面的一部分；
    - 可以恢复；
    - 重复相同操作可以消除错误。

  - 致命错误

    - 应用程序根本无法继续运行；
    - 错误明显影响到了用户的主要操作；
    - 会导致其他连带错误

- 建立JavaScript 错误记录系统

- 调试技术

  - 将消息记录到控制台

    - console系列
    - LiveConnect 在 JavaScript 中把消息写入到 Java 控制台

  - 将消息记录到当前页面

- 常见的 IE 错误 P518

  - 操作终止
  - 无效字符
  - 未找到成员

    - IE 中的所有 DOM 对象都是以 COM 对象，而非原生 JavaScript 对象的形式实现的

  - 未知运行时错误

  - 语法错误

  - 系统无法找到指定资源

```javascript
(function testFinally(){
  try {
      return 2;
  } catch (error){
      return 1;
  } finally {
      return 0;
  }
})();

var obj = x; // 在 x 并未声明的情况下抛出 ReferenceError
eval("a ++ b"); //抛出 SyntaxError

var o = new 10; //抛出 TypeError
alert("name" in true); //抛出 TypeError
Function.prototype.toString.call("name"); //抛出 TypeError

// 判断错误类型
try {
    someFunction();
} catch (error){
  if (error instanceof TypeError){
  // 处理类型错误
  } else if (error instanceof ReferenceError){
  // 处理引用错误
  } else {
  // 处理其他类型的错误
  }
}

// 抛出错误
throw 12345;
throw "Hello world!";
throw true;
throw { name: "JavaScript"};
throw new Error("Something bad happened.");

throw new SyntaxError("I don’t like your syntax.");
throw new TypeError("What type of variable do you take me for?");
throw new RangeError("Sorry, you just don’t have the range.");
throw new EvalError("That doesn’t evaluate.");
throw new URIError("Uri, is that you?");
throw new ReferenceError("You didn’t cite your references properly.");

// 继承 Error 来创建自定义错误类型
function CustomError(message){
  this.name = "CustomError";
  this.message = message;
}
CustomError.prototype = new Error();
throw new CustomError("My message");

// 阻止浏览器报告错误的默认行为。
window.onerror = function(message, url, line){
    alert(message);
    return false;
};

// 最好是使用 instanceof 来检测其数据类型
// 安全，非数组值将被忽略
function reverseSort(values){
  // if (values){ // 错误
  // if (values != null){ // 错误
  // if (typeof values.sort == "function"){ // 不要这样
  if (values instanceof Array){ // 问题解决了
    values.sort();
    values.reverse();
  }
}

// 定义一个处理查询字符串的函数
function addQueryStringArg(url, name, value){
  if (url.indexOf("?") == -1){
      url += "?";
  } else {
      url += "&";
  }
  url += encodeURIComponent(name) + "="
                  + encodeURIComponent(value);
  return url;
}

var url = "http://www.somedomain.com";
var newUrl = addQueryStringArg(url, "redir",
    "http://www.someotherdomain.com?a=b&c=d");
alert(newUrl);

// JS错误记录系统
function logError(sev, msg){
    var img = new Image();
    img.src = "log.php?sev=" + encodeURIComponent(sev) + "&msg=" +
        encodeURIComponent(msg);
}

for (var i=0, len=mods.length; i < len; i++){
  try {
      mods[i].init();
  } catch (ex){
      logError("nonfatal", "Module init failed: " + ex.message);
  }
}

// 不存在一种跨浏览器向 JavaScript 控制台写入消息的机制，
// 但下面的函数倒可以作为统一的接口
function log(message){
  if (typeof console == "object"){
  console.log(message);
  } else if (typeof opera == "object"){
  opera.postError(message);
  } else if (typeof java == "object" && typeof java.lang == "object"){
  java.lang.System.out.println(message);
  }
}

function log(message){
  var console = document.getElementById("debuginfo");
  if (console === null){
    console = document.createElement("div");
    console.id = "debuginfo";
    console.style.background = "#dedede";
    console.style.border = "1px solid silver";
    console.style.padding = "5px";
    console.style.width = "400px";
    console.style.position = "absolute";
    console.style.right = "0px";
    console.style.top = "0px";
    document.body.appendChild(console);
  }
  console.innerHTML += "<p>" + message + "</p>";
}
```

# 浏览器调试

- chrome开发者工具, 例如

  - Task Management
  - Profiles - Heap Snapshot
  - Timeline 内存时间轴

- console <http://ghmagical.com/article/page/id/S6S2E4BolVg7>

  - console.log发布前一定要删掉

- 工具文档 <http://www.css88.com/doc/chrome-devtools/settings/>

- 内存泄漏

  - 不再需要的变量一直没有释放
  - 函数闭包 removeEventListener
  - 多个对象之间的循环引用
  - 数据引用保存独立的局部变量副本

- 性能瓶颈

  - 即浏览器有时会出现一瞬间的锁定或冻结
  - 原因：浏览器渲染被迫优先处理JS解释器，使其赶上渲染速度
  - for 或 while迭代
  - Collect JavaScript CPU Profile

- 开发者工具

  - 前端工程师必会的6个调试技术 <https://read.douban.com/reader/column/5945187/chapter/30774228/>
  - <https://juejin.im/entry/5a0001b86fb9a0451a75c591?utm_source=gold_browser_extension>
  - 基本的调试： HTML、CSS 和 JavaScript
  - 使用网络工具对 API 进行测试

    - 状态码与错误
    - 设计表单时，我们可以看到它发出的参数是否是正确的

  - 对移动设备进行调试：**先在浏览器进行响应式设计，随后在真机上进行测试**。

  - 对网站的性能进行调试

  - 在控制台中输入debug(car.funcY)，当调用car.funcY时，将以调试模式停止

  - Postman 很棒，但Firefox更快

```javascript
// 让Chrome变成编辑器
document.body.contentEditable=true

// 打开命令菜单
Ctrl + Shift + P

// 如何在浏览器查看代码
1/.pretty-printing 重排版代码
2/.source maps 缩编时添加一个指向完整版的引用
// # souceMappingURL=/scripts/scripts.js.map
X-SourceMap: /scripts/scripts/js.map
3/.或使用UglifyJS或Google Closure Compiler实现

// 输出
console.info()  一般信息
console.bug()  辅助错误调试
console.warn() 指出 潜在问题 的具体情况
console.error() 出现 错误 并指出错误的具体情况

// 表格输出
var animals = [
    { animal: 'Horse', name: 'Henry', age: 43 },
    { animal: 'Dog', name: 'Fred', age: 13 },
    { animal: 'Cat', name: 'Frodo', age: 18 }
];

console.table(animals);

// 设置css输出

// 计时
console.time('Timer1');

var items = [];

for(var i = 0; i < 100000; i++){
   items.push({index: i});
}

console.timeEnd('Timer1');
```

- 发布时自动移除console对象

  - [grunt-strip](https://github.com/jsoverson/grunt-strip)
  - [gulp-strip-debug](https://github.com/sindresorhus/gulp-strip-debug)

# IDEA配置

- sass\less

- autoprefix

  - <http://www.css88.com/archives/5670>
  - <https://www.npmjs.com/package/less-plugin-autoprefix>

```javascript
npm install autoprefixer -g
npm install postcss-cli -g
npm install -g less
npm install -g less-plugin-clean-css
C:\Users\Administrator\AppData\Roaming\npm\postcss.cmd

Parameters: -u autoprefixer -o $FileDir$\$FileName$  $FileDir$\$FileName$
Working directory :$ProjectFileDir$

// npm install postcss-less
```

# 代码文件依赖管理

- 异步模块定义AMD

  - Asynchronous Module Definition

- [RequireJS](http://requirejs.org/docs/download.html)

  - RequireJS的优化工具 查看官网

    - UglifyJS压缩

  - RequireJS的附加插件

    - il8n 使文本实现本地化
    - Text 让文本文件也作为加载依赖
    - Font 通过Google的WebFont Loader API加载字体
    - Handlebars 函数的处理结果是一个HTML字符串，可以注入页面中
    - Cache 页面刷新从本地存储区加载，减少HTTP请求

  - RequireJS的替代品

    - BDLoad

      - Cajon
      - CurlJS
      - LoaderJS
      - UMD
      - Yabble

```javascript
// 定义一个对jQuery有依赖的模块
define(["lib/jquery-1.10.2"], function($) {
    // Module code to execute once jQuery is loaded goes here. The jQuery library
    // is manifest through the first parameter to this function, here named $
});

// 模块名称的别名
requirejs.config({
    paths: {
        "jquery": "lib/jquery-1.10.2"
    }
});

// 后备加载
requirejs.config({
    paths: {
        "jquery": [
            "https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min",
            // If the CDN fails, load from this local file instead
            "lib/jquery-1.10.2"
        ]
    }
});

// 一个RequireJS模块,作为jQuery验证插件进行使用
define(["jquery"], function($) {
    $.fn.isValidEmail = function() {
        var isValid = true,
            // Regular expression that matches if one or more non-whitespace characters are
            // followed by an @ symbol, followed by one or more non-whitespace characters,
            // followed by a dot (.) character, and finally followed by one or more non-
            // whitespace characters
            regEx = /\S+@\S+\.\S+/;

        this.each(function() {
            if (!regEx.test(this.value)) {
                isValid = false;
            }
        });

        return isValid;
    };
});

// 主应用脚本,与模块实现关联
require(["jquery", "lib/validation-plugin"], function($) {
    var $form = $("#form"),
        $email = $("#email");

    $form.on("submit", function(e) {
        e.preventDefault();
        if ($email.isValidEmail()) {
            $form.get(0).submit();
        } else {
            $email.addClass("error").focus();
        }
    });

    $email.on("keyup", function() {
        $email.removeClass("error");
    });
});

// 优化上面的代码,请求时才加载额外的脚本，但如果这个脚本比较大?
require(["jquery"], function($) {
    var $form = $("#form"),
        $email = $("#email");

    $form.on("submit", function(e) {
        e.preventDefault();
        require(["lib/validation-plugin"], function() {
            if ($email.isValidEmail()) {
                $form.get(0).submit();
            } else {
                $email.addClass("error").focus();
            }
        });
    });

    $email.on("keyup", function() {
        $email.removeClass("error");
    });
});
```

# 客户端模板引擎

- 基础

```javascript
// JS方法
function myFunction()
{
var obj=document.getElementById("h01");
obj.innerHTML="Hello jQuery";
}
onload=myFunction;

// JQuery方法
function myFunction() {
$("#h01").html("Hello jQuery");
}
$(document).ready(myFunction);

上面代码的最后一行，HTML DOM 文档对象被传递到 jQuery ：$(document)。
当您向 jQuery 传递 DOM 对象时，jQuery 会返回以 HTML DOM 对象包装的 jQuery 对象。

jQuery 函数会返回新的 jQuery 对象，其中的 ready() 是一个方法。
由于在 JavaScript 中函数就是变量，因此可以把 myFunction 作为变量传递给 jQuery 的 ready 方法。
不能在 jQuery 对象上使用 HTML DOM 的属性和方法
```

- Prototype

```javascript
与 jQuery 不同，Prototype 没有用以取代 window.onload() 的 ready() 方法。相反，Prototype 会向浏览器及 HTML DOM 添加扩展。

prototype方法

function myFunction() {
$("h01").insert("Hello Prototype!");
}
Event.observe(window,"load",myFunction);
```

- MooTools
- 其他框架

```javascript
YUI - Yahoo! User Interface Framework，
涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。

Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）

Dojo - 用于 DOM 操作、事件、widget 等的工具包。

script.aculo.us - 开源的 JavaScript 框架，针对可视效果和界面行为。

UIZE - Widget、AJAX、DOM、模板等等。
```

- 客户端模板引擎的使用

```javascript
主要应用于那些单页Web应用程序
动态更新页面内容 JS+HTML 但易混淆
通过Ajax动态加载HTML 可视化/DOM的更新 标记重复下载
应用模板(特定占位符 被数据内容替代)
体验先不依赖库实现 eg.regex.replace()
使用logic-less[Mustache.js](https://github.com/janl/mustache.js)
使用[Handlebars.js](http://handlebarsjs.com/)
替代引擎库
[EJS](http://www.embeddedjs.com) 远程JSON文件处理时的优势
Underscore.js(Backbone.js MVC)
SEO有关处理
网页URL原则 - 一个URL表示的应该是一个对象或一块内容，并不是整个网页应用程序
可进入独立特定的URL, JS防止链接或表单引起的页面刷新
Ajax 使用HTML5 History API
```

# Webpack简介

- 链接

  - [官网](http://webpack.github.io/)
  - [文档](http://webpack.github.io/docs/)
  - [入门](http://www.w2bc.com/Article/50764)

- 简介

  - 模块加载器 兼 打包 工具
  - 各种健全的 加载器
  - Github 上各大主流的 React 相关项目，所展示的示例是基于 webpack 来开发的

- commonJS AMD/CMD 代码迁移

  - 替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等
  - 支持 React 热插拔??
  - demo 自动加上自己的加载器 回调define...
  - 每个项目下都必须配置有一个 webpack.config.js

```javascript
var someModule = require("someModule");
    var anotherModule = require("anotherModule");    

    someModule.doTehAwesome();
    anotherModule.doMoarAwesome();

    exports.asplode = function (){
        someModule.doTehAwesome();
        anotherModule.doMoarAwesome();
 };

// 作用如同常规的 gulpfile.js/Gruntfile.js ，配置项，告诉 webpack 它需要做什么
var webpack = require('webpack');
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
// 提取多个入口文件的公共脚本部分
// 然后生成一个 common.js 来方便多页面之间进行复用

module.exports = {
    //插件项
    plugins: [commonsPlugin],
    //页面入口文件配置
    entry: {
        index : './src/js/page/index.js'
    },
    //入口文件输出配置
    output: {
        path: 'dist/js/page',
        filename: '[name].js'
    },
    // module.loaders 是最关键的一块配置
    // 它告知 webpack 每一种文件都需要使用什么加载器来处理
    module: {
        //加载器配置
        loaders: [
            { test: /\.css$/, loader: 'style-loader!css-loader' },
            { test: /\.js$/, loader: 'jsx-loader?harmony' },
            { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
            { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
        ]
    },
    //其它解决方案配置
    resolve: {
            //查找module的话从这里开始查找
            root: 'E:/github/flux-example/src', //绝对路径
            //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
            extensions: ['', '.js', '.json', '.scss'],
            //模块别名定义，方便后续直接引用别名，无须多写长长的地址
            alias: {
                AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
                ActionType : 'js/actions/ActionType.js',
                AppAction : 'js/actions/AppAction.js'
            }
        }
};


// 执行：$ webpack --display-error-details
// 其他
$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
$ webpack --watch   //监听变动并自动打包
$ webpack -p    //压缩混淆脚本，这个非常非常重要！
$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了

// 连样式都不用引入，脚本执行时会动态生成style并标签打到head里
// 脚本模块
require('../../css/reset.scss'); //加载初始化样式
require('../../css/allComponent.scss'); //加载组件样式
var React = require('react');
var AppWrap = require('../component/AppWrap'); //加载组件
var createRedux = require('redux').createRedux;
var Provider = require('redux/react').Provider;
var stores = require('AppStore');

var redux = createRedux(stores);

var App = React.createClass({
    render: function() {
        return (
            <Provider redux={redux}>
                {function() { return <AppWrap />; }}
            </Provider>
        );
    }
});

React.render(
    <App />, document.body
);

// 有用的技巧
// shimming：在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理
{ test: require.resolve("./src/js/tool/swipe.js"),  loader: "exports?swipe"}

require('./tool/swipe.js');
swipe();

// 自定义公共模块提取：
// 独立打包样式文件
var webpack = require('webpack');
    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        plugins: [commonsPlugin, new ExtractTextPlugin("[name].css")],
        entry: {
        //...省略其它配置


// 使用CDN/远程文件
{
    externals: {
        // require("jquery") 是引用自外部模块的
        // 对应全局变量 jQuery
        "jquery": "jQuery"
    }
}
var $script = require("scriptjs");
$script("//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js", function() {
  $('body').html('It works!')
});

// 与 grunt/gulp 配合
gulp.task("webpack", function(callback) {
    // run webpack
    webpack({
        // configuration
    }, function(err, stats) {
        if(err) throw new gutil.PluginError("webpack", err);
        gutil.log("[webpack]", stats.toString({
            // output options
        }));
        callback();
    });
});
```

# 压缩

- Gzip -- header Content-Encoding:gzip
- JS压缩

  - uglifyJS
  - YUI Compressor（仅仅压缩）
  - Closure Compiler

- CSS压缩

  - CSS Compressor

- HTML压缩

  - 有必要吗？
  - HtmlCompressor

- 图片资源压缩

  - 在线

    - TinyPNG
    - JEPGmini

  - 本地：ImageOptim

# Webpack

- [官网](http://webpack.github.io/) | [文档](http://webpack.github.io/docs/) | [入门](http://www.w2bc.com/Article/50764)

- 简介

  - 模块加载器 兼 打包工具
  - 各种健全的 加载器
  - Github 上各大主流的 React相关项目，所展示的示例是基于 webpack 来开发的

- commonJS AMD/CMD 代码迁移

  - 替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等
  - 支持 React 热插拔??
  - demo 自动加上自己的加载器 回调define...
  - 每个项目下都必须配置有一个 webpack.config.js

# JS文档

- 资源

  - [JSDoc](http://usejsdoc.org/) | [dox](https://github.com/tj/dox) | [YUIDoc](http://yui.github.io/yuidoc/)(业内倾向)

```javascript
// 文档定义
从源代码中提取特殊格式的文档

类比jQuery的文档
可以提高代码的可维护性

但注意保证文档的及时更新

// 一般的开始格式

让文档处理器只能理解我告诉它的东西 // 不要太智能

// Markdown
更具表达性的文档格式
转化成HTML更容易!
富文本
语法高亮 coding

// 使用YUIDoc创建一个文档网站
```

- node.js
- npm -g install yuidocjs
- cd /d , pushd dir
- yui (-n) .
- [github](http://yui.github.io/yuidoc/)
- [Dana主题](https://github.com/carlo/yuidoc-theme-dana)
- [more主题](http://yui.github.io/yuidoc/themes/)
- [官方语法指南](http://yui.github.io/yuidoc/syntax/)

# 静态代码分析工具

- [JSlint](http://www.jslint.com)

  - _jslint devel: true, nomen: true, white: true_
  - _global Class_
  - [在线文档](http://www.jslint.com/lint.html)

- [JSlint nodejs](https://github.com/reid/node-jslint)

  - npm install jslint
  - jslint *.js

- [JSHint](http://www.jshint.com)

  - 在意一个没有用到的变量
  - / _jshint devel: true, unused: false;_/
  - [在线文档](http://jshint.com/docs/options/)
  - npm install jshint -g
  - jshint *.js
  - [插件](http://jshint.com/install/)

- Google Closure Compiler

  - 提高JS代码的下载速度和执行速度
  - 发现语法错误
  - [在线](http://closure-compiler.appspot.com/home)
  - [java运行](https://developers.google.com/closure/compiler/docs/gettingstarted_app)
  - [REST Web服务API](https://developers.google.com/closure/compiler/docs/gettingstarted_api)

- Closure Linter

# 单元测试

- [QUnit](http://qunitjs.com/)
- [Mocha](http://mochajs.org/)

  - [ruanyf](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)

- [Jasmine](https://jasmine.github.io/)

  - [github](https://github.com/jasmine/jasmine)
  - [自定义](https://github.com/jasmine/jasmine)

- [BrowserStack](https://www.browserstack.com/)

- [Sauce Labs](http://saucelabs.com/)

# 处理运行时错误

- 类型

  - 语法错误
  - 类型错误
  - 范围错误
  - eval错误
  - 引用错误
  - URI错误 URI函数提供了错误的URL

- try-catch-finally

- 检测错误类型

- 自定义错误类型

```javascript
try {
  // Code that might throw an error to go here
} catch (error) {
  if (error instanceof SyntaxError) {
      // A syntax error was thrown
  } else if (error instanceof TypeError) {
      // A type error was thrown
  } else if (error instanceof RangeError) {
      // A range error was thrown
  } else if (error instanceof EvalError) {
      // An eval error was thrown
  } else if (error instanceof ReferenceError) {
      // A reference error was thrown
  } else if (error instanceof URIError) {
      // A URI error was thrown
  }
}
```

# 度量代码质量

- 代码覆盖率工具[Istanbul](https://github.com/gotwarlost/istanbul)

  - [ruanyf](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)
  - node.js npm grunt 任务执行器
  - npm install -g grunt-cli
  - npm install grunt-contrib-jasmine --save-dev
  - grunt default
  - [PhantomJS](http://phantomjs.org) 基于Webkit的无界面浏览器

- 代码分析 [Plato](https://github.com/es-analysis/plato)

  - npm install -g plato
  - plato -d reports src/*.js

# 优化页面加载时间

- HTML标签顺序
- GZip编码

  - appache mod_deflate模块
  - Node.js Express compress()
  - 预压缩 + HTTP报头Content-Encoding:gzip

- 缩编、混淆和编译

  - 缩编：去掉空格换行符
  - 混淆：高级 对限定作用域内的变量 重命名为简短的名称

    - 全局变量和函数越少越好

  - 编译：更先进 分析代码

- JSMin 缩编工具

  - npm install -g jsmin
  - jsmin -o Listing.min.js listing.js

- UglifyJS 缩编 + 混淆

  - <http://marijnhaverbeke.nl/uglifyjs>
  - npm install uglify-js -g
  - uglifyjs uglify-test.js -m -o uglify-test.min.js

- Google Closure Compiler 代码编译

  - <http://closure-compiler.appspot.com/home>

- 使用匿名、自执行的函数闭包来减少全局变量的使用

```javascript
// Define a global variable
var myGlobalVariable;
// Create a self-executing, anonymous (unnamed) function to wrap around your code
(function() {
    // Your code, that before was global, goes here with a new, non-global scope,
    // making it easier to generate smaller compressed files via minification,
    // obfuscation, or compilation

    // Define a local variable
    var myLocalVariable = "Local";

    // Set the global variable to a string
    myGlobalVariable = "Global";

// The open-close bracket combination here executes the function straight away
}());

//  请求时才延迟加载JS文件,从而不阻塞浏览器

function loadScript(src, onLoad) {
    var scriptTag = document.createElement("script");
    scriptTag.src = src;
    if (typeof onLoad === "function") {
        scriptTag.onload = onLoad;
        scripTag.onreadystatechange = function() {
            if (scriptTag.readyState === 4) {
                onLoad();
            }
        };
    }
    document.body.appendChild(scriptTag);
}
loadScript("my-script.js", function() {
   alert("script loaded and available!");
});
loadScript("my-script.js");
// 加载完不需要执行额外的代码，不需要第二个参数
```

# 优化文档对象的操作

- 实现对页面元素的最小化访问
- 尽量利用已有元素
- 离线DOM的利用 小型的元素树结构
- 使用CSS而非JS来操控页面样式

  - nav.style.opacity = 0.5; 不经济,引发重排
  - nav.className += "selected"; good
  - 利用dispaly

```javascript
var nav = document.getElementsByTagName("nav");
nav.style.display = "none"; // Causes a browser reflow, hiding the element from display
nav.style.backgroundColor = "#000"; // Causes no reflow since the element is hidden
nav.style.color = "#fff"; // Causes no reflow
nav.style.opacity = 0.5; // Causes no reflow
nav.style.display = "block"; // Causes a browser reflow, bringing the element back on display
```

# 提升DOM事件性能

- 委托事件至父元素
- 使用框架化处理频密发出的事件

  - 频密事件：mousemove resize scroll touchmove

# 提升函数性能

- 使用记忆功能
- 一般性函数

# 使用正则表达式实现更快速的字符串操作

# 更快速地使用数组

- 保存array.length的值

```javascript
// The most common type of loop
for (var index = 0; index < myArray.length; index++) {}
// A similar but much faster version of the same loop
for (var index = 0, length = myArray.length; index < length; index++) {}
```

- 使用continue和break
- 反向while循环 coding
- 避免在循环中创建函数

# 转移密集型任务至Web Worker

- 例处理图像数据
