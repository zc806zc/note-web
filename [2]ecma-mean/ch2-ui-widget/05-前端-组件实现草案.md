# 简述

- 优秀网站

  - jq22.com

- 组件分类

  - <http://ghmagical.com/article/page/id/aqy7vR3DegbG>
  - 自己分为6种

    - panel(轮播|弹出框等出现显隐, 目的是增大展示面积)
    - form(表格表单等以数据交互为目的)
    - tool(工具性很强的，例如阅读器)
    - effects(特效)
    - game(粘性为目的的小游戏,canvas为主，创意优先)

# 1\. panel

- 轮播图

  - 别再使用轮播图了 <https://juejin.im/post/599cf1596fb9a02481205803?utm_source=gold_browser_extension>
  - 切割轮播图 <http://www.jq22.com/webqd2833>

> 轮播图: 1% 的用户点击却占用了页面一半甚至更多的位置

- 对话框和灯箱
- 弹出层与工具提示(也可以属于tool)
- 布局
- Tabs
- 导航

  - 水平导航
  - 垂直导航
  - 文件树
  - 手风琴导航
  - 分页
  - 其他导航

# 2\. form

- 按钮

  - btn-css-generator <http://www.bestcssbuttongenerator.com/#/8>
  - 防止表单重复提交的loading

![](/assets/import-double-submit.png)

- 登录

  - <https://profile.freepik.com/login>
  - 复位这个按钮几乎永远都不会帮助到用户

![](/assets/login-sample-23.png)

- 用户很可能不愿意填写表单

  - 逻辑分组
  - 重视交互，做有意思的设计

- 表格 <https://colorlib.com/wp/css3-table-templates/>

  - Crisp table <http://codepen.io/stursby/pen/HdiJh>
  - heavy table <http://codepen.io/victordarras/pen/hJHAm?editors=0110>

- 筛选排序

- 图表

- 输入

  - 通用输入
  - 拾色器
  - 定制和风格
  - 时间日期
  - 拖放
  - 自动完成
  - 密码
  - 投票率
  - 搜索
  - 选择框
  - 快捷键
  - 触摸
  - 丰富的输入
  - 上传
  - 验证

    - <http://www.jq22.com/webqd2853>

# 3\. tool

- 客服反馈
- 滚动条

  - slimScroll

- 返回顶部

  - <http://www.jq22.com/webqd2804>

```javascript
$(function() {
  // 监听一定的高度
  $(window).scroll(function() {
      if ($(window).scrollTop() >= 300) {
          $('.gongyong a').fadeIn(600);
      } else {
          $('.gongyong a').fadeOut(600);
      }
  });
  $('.bottom a').click(function() {
      $("html,body").animate({
          scrollTop: $(document).height()
      }, 500);
  });
});
```

- 音频和视频
- 图像
- 地图
- 浏览器调整
- 格式化CSS代码 <http://www.jq22.com/webqd2886>

  - 正则表达式

- canvas选座位 <http://www.jq22.com/webqd3040>

- 广告

  - 优雅地做广告

- 打印

  - jqprint <http://www.jq22.com/jquery-info347>

- 计算器

  - 支持多进制<http://www.jq22.com/webqd3218>

```javascript
switch (sign) {
    case "+":
        document.getElementById("pm").innerHTML = parseFloat(op1) + parseFloat(document.getElementById("pm").innerHTML);
        break;
    ...

    case "x^y":
        document.getElementById("pm").innerHTML = Math.pow(parseFloat(op1), parseFloat(document.getElementById("pm").innerHTML));
        break;
}
```

# 4\. effect

- 缓动效果/逐帧动画/闪烁动画
- 状态平滑的动画

- CSS3-3D立方体 <http://www.html5tricks.com/demo/css3-3d-cube-rotate/index.html>

- 打字动画

  - typetype <https://github.com/iamdanfox/typetype>

```javascript
var zi = "这是个神奇的网站！";
var i = 0;
var divObj; //全局变量
function init() {
    divObj = document.getElementById("divId");
    setInterval(show, 200); //每个指定的毫秒执行一次函数
}init();

function show() {
    i++;
    var jzi = zi.substring(0, i); //截取字符串，每次截取一个
    divObj.innerHTML = jzi; //往div设置内容
    if (i == zi.length) { //当字符串写完后，重新开始执行
        i = 0;
    }
}
```

- 纸张效果 <http://www.zhangxinxu.com/wordpress/2011/02/几种纯csscss3下的纸张效果展示/>
- 锯齿效果 <http://www.softwhy.com/forum.php?mod=viewthread&tid=19089>
- 加载

  - <https://codepen.io/collection/jifIK/>
  - <https://github.com/tobiasahlin/SpinKit>

- 动画效果

```javascript
默认情况下，所有 HTML 元素的位置都是静态的，并且无法移动。如需对位置进行操作，记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute。
```

- 图片炸裂 <http://www.jq22.com/webqd3028>

- 拖放

  - draggable <https://github.com/Shopify/draggable>
  - 图片 <http://www.jq22.com/webqd2950>
  - 支持排序 <http://www.jq22.com/webqd2944>

```javascript
// 图片拖放
<div id="wrap2" class="wrap" ondragover="allowDrop(event)" ondrop="drop(event)"></div>

function drop(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData("Img");
    ev.target.appendChild(document.getElementById(data));
}

// 拖拽排序
function DragDrop(id) {
    this.parentBox = document.getElementById(id)
    this.editSwith = this.parentBox.querySelector('.editOrder');
    this.save = this.parentBox.querySelector('.save');
    this.list = this.parentBox.querySelector('.list');
    this.li = this.list.querySelectorAll('li');
    this.aPosXY = []; //原始位置
    this.aPosXYClone = [];
    this.moveStatus = false; //移动状态
    this.editAble = false; //编辑状态
    this.dashedBox = null;
    this.moveItem = null;
    this.moveItemH = null;
    this.mouseDownPos = [];
    this.inScope = false;
}

//鼠标移动
DragDrop.prototype.mouseMove = function(e, obj) {

    var relativeListX = e.pageX - this.list.offsetLeft; //鼠标相对ul的位置 x
    var relativeListY = e.pageY - this.list.offsetTop; //鼠标相对ul的位置 y
    var objIndex = obj.getAttribute('data-index'); //获取当前选中元素的下标
    var objLeft = this.aPosXY[objIndex].x;
    var objTop = this.aPosXY[objIndex].y; //根据下标获取当前选中元素 固定的时候的定位 x,y;
    //      console.log('objLeft：'+objLeft+'  objTop：'+objTop); //  objLeft：10px  objTop：10px
    var relativeObjX = this.mouseDownPos.x - parseInt(objLeft); //鼠标按下时鼠标相对于选中元素的位置x
    var relativeObjY = this.mouseDownPos.y - parseInt(objTop); //鼠标按下时鼠标相对于选中元素的位置y
    var objMoveX = relativeListX - relativeObjX;
    var objMoveY = relativeListY - relativeObjY;
    //      console.log(objMoveX +'  '+objMoveY)
    //      console.log('x:'+relativeListX+' y:'+relativeListY);
    //      console.log('x:'+relativeObjX+' y:'+relativeObjY);
    setCss(obj, {
        'left': objMoveX + 'px',
        'top': objMoveY + 'px'
    });
    for (var i = 0; i < this.aPosXYClone.length; i++) {
        if (!(i == objIndex)) {
            if (objMoveY + obj.offsetHeight >= parseInt(this.aPosXYClone[i].y) + this.li[i].offsetHeight / 2 && objMoveY + obj.offsetHeight < parseInt(this.aPosXYClone[i].y) + this.li[i].offsetHeight || objMoveY >= parseInt(this.aPosXYClone[i].y) && objMoveY < parseInt(this.aPosXYClone[i].y) + this.li[i].offsetHeight / 2) {
                //            console.log(i);
                var ts = [];
                ts.x = this.dashedBox.style.left;
                ts.y = this.dashedBox.style.top;
                this.aPosXYClone[objIndex] = this.aPosXYClone[i];
                this.aPosXYClone[i] = ts;
                setCss(this.dashedBox, {
                    'left': this.aPosXYClone[objIndex].x,
                    'top': this.aPosXYClone[objIndex].y
                });
                setCss(this.li[i], {
                    'left': ts.x,
                    'top': ts.y
                });
                //            console.log(this.aPosXYClone)
                //            console.log(this.aPosXY)
                return false;
            }
        }
    }

}
```

# 5\. game

- 找不同色块 <http://www.jq22.com/webqd2835>
- 碰撞检测

```javascript
function judgeCrash(obj) {
    this.first = obj.elem1;
    this.second = obj.elem2;
    this.fnS = obj.fnS;
    this.fnE = obj.fnE;
    this.judge = function() {
        var Stop = this.second.offsetTop;
        var Sleft = this.second.offsetLeft;
        var Ftop = this.first.offsetTop;
        var Fleft = this.first.offsetLeft;
        var minLeft = Fleft - this.second.offsetWidth;
        var maxLeft = Fleft + this.first.offsetWidth;
        var minTop = Ftop - this.second.offsetHeight;
        var maxTop = Ftop + this.first.offsetHeight;
        if (Sleft >= minLeft && Sleft <= maxLeft && Stop >= minTop && Stop <= maxTop) {
            if (this.fnS) { //判断fun有没有
                this.fnS();
                return;
            }
        }
        if (this.fnE) { //判断error有没有
            this.fnE();
        }
    }
    var fn = this.judge;
    this.first.onmousedown = function(event) {
        var t = this; //t=this.first
        console.log(t)
        var startX = event.clientX;
        var startY = event.clientY;
        var offX = t.offsetLeft;
        var offY = t.offsetTop;
        document.onmousemove = function(event) {
            var theleft = event.clientX - startX;
            var theTop = event.clientY - startY;
            fn();
            t.style.left = offX + theleft + 'px';
            t.style.top = offY + theTop + 'px';
        }
        document.onmouseup = function(event) {
            document.onmousemove = null;
        }
    }
}

judgeCrash({
    elem1: second1,
    elem2: first1,
    fnS: function() {
        console.log("Yes");
        document.getElementById('one').innerHTML = 'Yes';
    },
    fnE: function() {

    }
});
```
