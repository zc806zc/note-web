# 创建对象

```javascript
var person= {}; // 少用new
person.firstname="John";
person.run  = function(){}; // 自动添加属性

// 添加方法到对象
function person(firstname,lastname,age,eyecolor) {
  this.firstname=firstname;
  this.lastname=lastname;
  this.age=age;
  this.eyecolor=eyecolor;

  // 方法
  this.changeName=changeName;
  function changeName(name) {
     this.lastname=name;
  }

}
myFather = new person("John","Doe",50,"blue");
myFather.changeName("Doe");
```

# 实现继承

- 原型链
- 函数伪装
- 原型链 + 函数伪装(正确打开方式)

```javascript
// 第一部分
function Parent(name){
  this.color = ["red","blue"];
  this.name = name;
}
Parent.prototype.talk = function(){
  alert(this.name+"["+this.color+"]");
}

// 第二部分
function Child(name,age){
  //函数伪造继承
  Parent.call(this,name);
  this.age = age;
}

// 原型链继承
Child.prototype = new Parent();

Child.prototype.say = function(){
  alert(this.name+","+this.color);
}

//第三部分
var c1 = new Child("Leon",22);
c1.color.push("green");
c1.say();     // 输出：Leon[red,blue,green]
var c2 = new Child("Ada",25);
c2.say();     // 输出：Ada[red,blue]
```

# 面向对象编程指南

- <https://github.com/batmanimal/object-oriented-js>

- 博客 <http://www.cnblogs.com/zengFyzL/>

- 重新理解JS的6种继承方式 <https://www.cnblogs.com/ayqy/p/4471638.html>

  - 简单原型链 Sub.prototype = new Super();
  - 借用构造函数 Super.call(this, val);
  - 组合继承（最常用）Sub.prototype = new Super(); + Super.call(this, val);
  - 原型式
  - 寄生式(给原型式继承穿了个马甲而已，看起来更像继承了) ：创建新对象 -> 增强 -> 返回该对象
  - 寄生组合继承（最佳方式）有缺陷的寄生式继承 + 不完美的组合继承 = 完美的寄生组合式继承

```javascript
// 寄生组合继承
function beget(obj){   // 生孩子函数 beget：龙beget龙，凤beget凤。
    var F = function(){};
    F.prototype = obj;
    return new F();
}
function Super(){
    // 只在此处声明基本属性和引用属性
    this.val = 1;
    this.arr = [1];
}
//  在此处声明函数
Super.prototype.fun1 = function(){};
Super.prototype.fun2 = function(){};
//Super.prototype.fun3...
function Sub(){
    Super.call(this);   // 核心
    // ...
}
var proto = beget(Super.prototype); // 核心
proto.constructor = Sub;            // 核心
Sub.prototype = proto;              // 核心

var sub = new Sub();
alert(sub.val);
alert(sub.arr);
```

# 模拟方式
