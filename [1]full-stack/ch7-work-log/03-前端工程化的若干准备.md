# idea配置

- sass\less

- autoprefix

  - <http://www.cnblogs.com/xuange306/p/6149074.html?utm_source=itdadao&utm_medium=referral>

```javascript
npm install postcss-cli -g
C:\Users\Administrator\AppData\Roaming\npm\postcss.cmd

Parameters: -u autoprefixer -o $FileDir$\$FileName$  $FileDir$\$FileName$
Working directory :$ProjectFileDir$
```

# 代码文件依赖管理

- 异步模块定义AMD

  - Asynchronous Module Definition

- [RequireJS](http://requirejs.org/docs/download.html)

  - RequireJS的优化工具 查看官网

    - UglifyJS压缩

  - RequireJS的附加插件

    - il8n 使文本实现本地化
    - Text 让文本文件也作为加载依赖
    - Font 通过Google的WebFont Loader API加载字体
    - Handlebars 函数的处理结果是一个HTML字符串，可以注入页面中
    - Cache 页面刷新从本地存储区加载，减少HTTP请求

  - RequireJS的替代品

    - BDLoad

      - Cajon
      - CurlJS
      - LoaderJS
      - UMD
      - Yabble

```javascript
// 定义一个对jQuery有依赖的模块
define(["lib/jquery-1.10.2"], function($) {
    // Module code to execute once jQuery is loaded goes here. The jQuery library
    // is manifest through the first parameter to this function, here named $
});

// 模块名称的别名
requirejs.config({
    paths: {
        "jquery": "lib/jquery-1.10.2"
    }
});

// 后备加载
requirejs.config({
    paths: {
        "jquery": [
            "https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min",
            // If the CDN fails, load from this local file instead
            "lib/jquery-1.10.2"
        ]
    }
});

// 一个RequireJS模块,作为jQuery验证插件进行使用
define(["jquery"], function($) {
    $.fn.isValidEmail = function() {
        var isValid = true,
            // Regular expression that matches if one or more non-whitespace characters are
            // followed by an @ symbol, followed by one or more non-whitespace characters,
            // followed by a dot (.) character, and finally followed by one or more non-
            // whitespace characters
            regEx = /\S+@\S+\.\S+/;

        this.each(function() {
            if (!regEx.test(this.value)) {
                isValid = false;
            }
        });

        return isValid;
    };
});

// 主应用脚本,与模块实现关联
require(["jquery", "lib/validation-plugin"], function($) {
    var $form = $("#form"),
        $email = $("#email");

    $form.on("submit", function(e) {
        e.preventDefault();
        if ($email.isValidEmail()) {
            $form.get(0).submit();
        } else {
            $email.addClass("error").focus();
        }
    });

    $email.on("keyup", function() {
        $email.removeClass("error");
    });
});

// 优化上面的代码,请求时才加载额外的脚本，但如果这个脚本比较大?
require(["jquery"], function($) {
    var $form = $("#form"),
        $email = $("#email");

    $form.on("submit", function(e) {
        e.preventDefault();
        require(["lib/validation-plugin"], function() {
            if ($email.isValidEmail()) {
                $form.get(0).submit();
            } else {
                $email.addClass("error").focus();
            }
        });
    });

    $email.on("keyup", function() {
        $email.removeClass("error");
    });
});
```

# 客户端模板引擎

- 基础

```javascript
// JS方法
function myFunction()
{
var obj=document.getElementById("h01");
obj.innerHTML="Hello jQuery";
}
onload=myFunction;

// JQuery方法
function myFunction() {
$("#h01").html("Hello jQuery");
}
$(document).ready(myFunction);

上面代码的最后一行，HTML DOM 文档对象被传递到 jQuery ：$(document)。
当您向 jQuery 传递 DOM 对象时，jQuery 会返回以 HTML DOM 对象包装的 jQuery 对象。

jQuery 函数会返回新的 jQuery 对象，其中的 ready() 是一个方法。
由于在 JavaScript 中函数就是变量，因此可以把 myFunction 作为变量传递给 jQuery 的 ready 方法。
不能在 jQuery 对象上使用 HTML DOM 的属性和方法
```

- Prototype

```javascript
与 jQuery 不同，Prototype 没有用以取代 window.onload() 的 ready() 方法。相反，Prototype 会向浏览器及 HTML DOM 添加扩展。

prototype方法

function myFunction() {
$("h01").insert("Hello Prototype!");
}
Event.observe(window,"load",myFunction);
```

- MooTools
- 其他框架

```javascript
YUI - Yahoo! User Interface Framework，
涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。

Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）

Dojo - 用于 DOM 操作、事件、widget 等的工具包。

script.aculo.us - 开源的 JavaScript 框架，针对可视效果和界面行为。

UIZE - Widget、AJAX、DOM、模板等等。
```

- 客户端模板引擎的使用

```javascript
+ 主要应用于那些单页Web应用程序
+ 动态更新页面内容 JS+HTML 但易混淆
+ 通过Ajax动态加载HTML 可视化/DOM的更新 标记重复下载
+ 应用模板(特定占位符 被数据内容替代)
+ 体验先不依赖库实现 eg.regex.replace()
+ 使用logic-less[Mustache.js](https://github.com/janl/mustache.js)
+ 使用[Handlebars.js](http://handlebarsjs.com/)
+ 替代引擎库
+ [EJS](http://www.embeddedjs.com) 远程JSON文件处理时的优势
+ Underscore.js(Backbone.js MVC)
+ SEO有关处理
+ 网页URL原则 - 一个URL表示的应该是一个对象或一块内容，并不是整个网页应用程序
+ 可进入独立特定的URL, JS防止链接或表单引起的页面刷新
+ Ajax 使用HTML5 History API
```

# Webpack简介

- 链接

  - [官网](http://webpack.github.io/)
  - [文档](http://webpack.github.io/docs/)
  - [入门](http://www.w2bc.com/Article/50764)

- 简介

  - 模块加载器 兼 打包 工具
  - 各种健全的 加载器
  - Github 上各大主流的 React 相关项目，所展示的示例是基于 webpack 来开发的

- commonJS AMD/CMD 代码迁移

  - 替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等
  - 支持 React 热插拔??
  - demo 自动加上自己的加载器 回调define...
  - 每个项目下都必须配置有一个 webpack.config.js

```javascript
var someModule = require("someModule");
    var anotherModule = require("anotherModule");    

    someModule.doTehAwesome();
    anotherModule.doMoarAwesome();

    exports.asplode = function (){
        someModule.doTehAwesome();
        anotherModule.doMoarAwesome();
 };

// 作用如同常规的 gulpfile.js/Gruntfile.js ，配置项，告诉 webpack 它需要做什么
var webpack = require('webpack');
var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
// 提取多个入口文件的公共脚本部分
// 然后生成一个 common.js 来方便多页面之间进行复用

module.exports = {
    //插件项
    plugins: [commonsPlugin],
    //页面入口文件配置
    entry: {
        index : './src/js/page/index.js'
    },
    //入口文件输出配置
    output: {
        path: 'dist/js/page',
        filename: '[name].js'
    },
    // module.loaders 是最关键的一块配置
    // 它告知 webpack 每一种文件都需要使用什么加载器来处理
    module: {
        //加载器配置
        loaders: [
            { test: /\.css$/, loader: 'style-loader!css-loader' },
            { test: /\.js$/, loader: 'jsx-loader?harmony' },
            { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
            { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
        ]
    },
    //其它解决方案配置
    resolve: {
            //查找module的话从这里开始查找
            root: 'E:/github/flux-example/src', //绝对路径
            //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名
            extensions: ['', '.js', '.json', '.scss'],
            //模块别名定义，方便后续直接引用别名，无须多写长长的地址
            alias: {
                AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可
                ActionType : 'js/actions/ActionType.js',
                AppAction : 'js/actions/AppAction.js'
            }
        }
};


// 执行：$ webpack --display-error-details
// 其他
$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包
$ webpack --watch   //监听变动并自动打包
$ webpack -p    //压缩混淆脚本，这个非常非常重要！
$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了

// 连样式都不用引入，脚本执行时会动态生成style并标签打到head里
// 脚本模块
require('../../css/reset.scss'); //加载初始化样式
require('../../css/allComponent.scss'); //加载组件样式
var React = require('react');
var AppWrap = require('../component/AppWrap'); //加载组件
var createRedux = require('redux').createRedux;
var Provider = require('redux/react').Provider;
var stores = require('AppStore');

var redux = createRedux(stores);

var App = React.createClass({
    render: function() {
        return (
            <Provider redux={redux}>
                {function() { return <AppWrap />; }}
            </Provider>
        );
    }
});

React.render(
    <App />, document.body
);

// 有用的技巧
// shimming：在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理
{ test: require.resolve("./src/js/tool/swipe.js"),  loader: "exports?swipe"}

require('./tool/swipe.js');
swipe();

// 自定义公共模块提取：
// 独立打包样式文件
var webpack = require('webpack');
    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        plugins: [commonsPlugin, new ExtractTextPlugin("[name].css")],
        entry: {
        //...省略其它配置


// 使用CDN/远程文件
{
    externals: {
        // require("jquery") 是引用自外部模块的
        // 对应全局变量 jQuery
        "jquery": "jQuery"
    }
}
var $script = require("scriptjs");
$script("//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js", function() {
  $('body').html('It works!')
});

// 与 grunt/gulp 配合
gulp.task("webpack", function(callback) {
    // run webpack
    webpack({
        // configuration
    }, function(err, stats) {
        if(err) throw new gutil.PluginError("webpack", err);
        gutil.log("[webpack]", stats.toString({
            // output options
        }));
        callback();
    });
});
```

# 压缩

- Gzip -- header Content-Encoding:gzip
- JS压缩

  - uglifyJS
  - YUI Compressor（仅仅压缩）
  - Closure Compiler

- CSS压缩

  - CSS Compressor

- HTML压缩

  - 有必要吗？
  - HtmlCompressor

- 图片资源压缩

  - 在线：TinyPNG JEPGmini
  - 本地：ImageOptim

--------------------------------------------------------------------------------

# Webpack

- [官网](http://webpack.github.io/) | [文档](http://webpack.github.io/docs/) | [入门](http://www.w2bc.com/Article/50764)

- 简介

  - 模块加载器 兼 打包工具
  - 各种健全的 加载器
  - Github 上各大主流的 React相关项目，所展示的示例是基于 webpack 来开发的

- commonJS AMD/CMD 代码迁移

  - 替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等
  - 支持 React 热插拔??
  - demo 自动加上自己的加载器 回调define...
  - 每个项目下都必须配置有一个 webpack.config.js

# JS文档

- 资源

  - [JSDoc](http://usejsdoc.org/) | [dox](https://github.com/tj/dox) | [YUIDoc](http://yui.github.io/yuidoc/)(业内倾向)

```javascript
// 文档定义
从源代码中提取特殊格式的文档

类比jQuery的文档
可以提高代码的可维护性

但注意保证文档的及时更新

// 一般的开始格式

让文档处理器只能理解我告诉它的东西 // 不要太智能

// Markdown
更具表达性的文档格式
转化成HTML更容易!
富文本
语法高亮 coding

// 使用YUIDoc创建一个文档网站
```

- node.js
- npm -g install yuidocjs
- cd /d , pushd dir
- yui (-n) .
- [github](http://yui.github.io/yuidoc/)
- [Dana主题](https://github.com/carlo/yuidoc-theme-dana)
- [more主题](http://yui.github.io/yuidoc/themes/)
- [官方语法指南](http://yui.github.io/yuidoc/syntax/)

# 静态代码分析工具

- [JSlint](http://www.jslint.com)

  - / _jslint devel: true, nomen: true, white: true_ /
  - / _global Class_ /
  - [在线文档](http://www.jslint.com/lint.html)

- [JSlint nodejs](https://github.com/reid/node-jslint)

  - npm install jslint
  - jslint *.js

- [JSHint](http://www.jshint.com)

  - 在意一个没有用到的变量
  - / _jshint devel: true, unused: false;_/
  - [在线文档](http://jshint.com/docs/options/)
  - npm install jshint -g
  - jshint *.js
  - [插件](http://jshint.com/install/)

- Google Closure Compiler

  - 提高JS代码的下载速度和执行速度
  - 发现语法错误
  - [在线](http://closure-compiler.appspot.com/home)
  - [java运行](https://developers.google.com/closure/compiler/docs/gettingstarted_app)
  - [REST Web服务API](https://developers.google.com/closure/compiler/docs/gettingstarted_api)

- Closure Linter

# 单元测试

- [QUnit](http://qunitjs.com/)
- [Mocha](http://mochajs.org/)

  - [ruanyf](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)

- [Jasmine](https://jasmine.github.io/)

  - [github](https://github.com/jasmine/jasmine)
  - [自定义](https://github.com/jasmine/jasmine)

- [BrowserStack](https://www.browserstack.com/)

- [Sauce Labs](http://saucelabs.com/)

# 处理运行时错误

- 类型

  - 语法错误
  - 类型错误
  - 范围错误
  - eval错误
  - 引用错误
  - URI错误 URI函数提供了错误的URL

- try-catch-finally

- 检测错误类型

- 自定义错误类型

```javascript
try {
  // Code that might throw an error to go here
} catch (error) {
  if (error instanceof SyntaxError) {
      // A syntax error was thrown
  } else if (error instanceof TypeError) {
      // A type error was thrown
  } else if (error instanceof RangeError) {
      // A range error was thrown
  } else if (error instanceof EvalError) {
      // An eval error was thrown
  } else if (error instanceof ReferenceError) {
      // A reference error was thrown
  } else if (error instanceof URIError) {
      // A URI error was thrown
  }
}
```

# 度量代码质量

- 代码覆盖率工具[Istanbul](https://github.com/gotwarlost/istanbul)

  - [ruanyf](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)
  - node.js npm grunt 任务执行器
  - npm install -g grunt-cli
  - npm install grunt-contrib-jasmine --save-dev
  - grunt default
  - [PhantomJS](http://phantomjs.org) 基于Webkit的无界面浏览器

- 代码分析 [Plato](https://github.com/es-analysis/plato)

  - npm install -g plato
  - plato -d reports src/*.js

# 优化页面加载时间

- HTML标签顺序
- GZip编码

  - appache mod_deflate模块
  - Node.js Express compress()
  - 预压缩 + HTTP报头Content-Encoding:gzip

- 缩编、混淆和编译

  - 缩编：去掉空格换行符
  - 混淆：高级 对限定作用域内的变量 重命名为简短的名称

    - 全局变量和函数越少越好

  - 编译：更先进 分析代码

- JSMin 缩编工具

  - npm install -g jsmin
  - jsmin -o Listing.min.js listing.js

- UglifyJS 缩编 + 混淆

  - [在线](http://marijnhaverbeke.nl/uglifyjs)
  - npm install uglify-js -g
  - uglifyjs uglify-test.js -m -o uglify-test.min.js

- Google Closure Compiler 代码编译

  - [在线](http://closure-compiler.appspot.com/home)

- 使用匿名、自执行的函数闭包来减少全局变量的使用

```javascript
    // Define a global variable
    var myGlobalVariable;
    // Create a self-executing, anonymous (unnamed) function to wrap around your code
    (function() {
        // Your code, that before was global, goes here with a new, non-global scope,
        // making it easier to generate smaller compressed files via minification,
        // obfuscation, or compilation

        // Define a local variable
        var myLocalVariable = "Local";

        // Set the global variable to a string
        myGlobalVariable = "Global";

    // The open-close bracket combination here executes the function straight away
    }());

//  请求时才延迟加载JS文件,从而不阻塞浏览器

    function loadScript(src, onLoad) {
        var scriptTag = document.createElement("script");
        scriptTag.src = src;
        if (typeof onLoad === "function") {
            scriptTag.onload = onLoad;
            scripTag.onreadystatechange = function() {
                if (scriptTag.readyState === 4) {
                    onLoad();
                }
            };
        }
        document.body.appendChild(scriptTag);
    }
    loadScript("my-script.js", function() {
       alert("script loaded and available!");
    });
    loadScript("my-script.js");
    // 加载完不需要执行额外的代码，不需要第二个参数
```

# 优化文档对象的操作

- 实现对页面元素的最小化访问
- 尽量利用已有元素
- 离线DOM的利用 小型的元素树结构
- 使用CSS而非JS来操控页面样式

  - `nav.style.opacity = 0.5;` 不经济,引发重排
  - `nav.className += "selected";` good
  - 利用dispaly

```javascript
    var nav = document.getElementsByTagName("nav");
    nav.style.display = "none"; // Causes a browser reflow, hiding the element from display
    nav.style.backgroundColor = "#000"; // Causes no reflow since the element is hidden
    nav.style.color = "#fff"; // Causes no reflow
    nav.style.opacity = 0.5; // Causes no reflow
    nav.style.display = "block"; // Causes a browser reflow, bringing the element back on display
```

# 提升DOM事件性能

- 委托事件至父元素
- 使用框架化处理频密发出的事件

  - 频密事件：mousemove resize scroll touchmove

# 提升函数性能

- 使用记忆功能
- 一般性函数

# 使用正则表达式实现更快速的字符串操作

# 更快速地使用数组

- 保存array.length的值

```javascript
// The most common type of loop
for (var index = 0; index < myArray.length; index++) {}
// A similar but much faster version of the same loop
for (var index = 0, length = myArray.length; index < length; index++) {}
```

- 使用continue和break
- 反向while循环 coding
- 避免在循环中创建函数

# 转移密集型任务至Web Worker

- 例处理图像数据
